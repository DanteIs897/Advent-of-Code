===== RESUMEN DEL PROYECTO =====


===== TREE ./src =====
./src
├── cli.rs
├── errors.rs
├── main.rs
├── models.rs
├── utils
│   ├── mod.rs
│   └── openfiles.rs
├── years
│   ├── y2024
│   │   └── day_01.rs
│   └── y2024.rs
└── years.rs

4 directories, 9 files


===== ARCHIVOS en ./src =====


===== ./src/main.rs =====

mod cli;
mod utils;
mod years;
mod errors;
mod models;

use clap::Parser;
use cli::Args;

fn main() {
    let args = Args::parse();
    let year = args.year.parse::<u16>().unwrap();
    let day = args.day.parse::<u8>().unwrap();
    
    if let Err(e) = years::dispatch(year, day) {
        eprintln!("Error: {}", e);
    }
}


===== ./src/utils/openfiles.rs =====

use std::fs;
use std::path::PathBuf;


pub fn open_input(year: u16, day: u8) -> Result<String, std::io::Error> {
  let day_str = format!("{:02}", day);
  
  let mut path = PathBuf::from("inputs");
  path.push(format!("y{}", year));
  path.push(format!("{}.txt", day_str));
  
  
  fs::read_to_string(path)
}

===== ./src/utils/mod.rs =====

pub mod openfiles;


===== ./src/years/y2024/day_01.rs =====

use crate::utils::openfiles::open_input;
use crate::errors::AocError;

pub fn run() {
  let input = open_input(2024, 1).map_err(|e| AocError::Io(e))?;
  println!("Día 01 - Entrada: {} líneas", input.lines().count());
  
  let mut left = Vec::new();
  let mut right = Vec::new();
  
  for line in input.lines() {
    let parts: Vec<&str> = line.split("   ").collect();
    
    if parts.len() == 2 {
      let l = parts[0].trim().parse::<i32>().unwrap();
      let r = parts[1].trim().parse::<i32>().unwrap();
      left.push(l);
      right.push(r);
    }
  }
  
  left.sort();
  right.sort();
  
  let mut total_diff = 0;
  for (l, r) in left.iter().zip(right.iter()) {
    let diff = if l > r {
      l - r
    } else {
      r - l
    };
    total_diff += diff;
  }
  
  println!("Respuesta 1: {}", total_diff);
  
  let mut sim_score = 0;
  
  for l in &left {
    let count = right.iter().filter(|&&r| r == *l).count();
    sim_score += *l * count as i32;
  }
  
  println!("Respuesta 2: {}", sim_score);
  
}


===== ./src/years/y2024.rs =====

pub mod day_01;

use crate::errors::AocError;

pub fn run_day(day: u8) -> Result<(), AocError> {
  match day {
	1 => Ok(day_01::run()),
	_ => Err(AocError::Unsupported),
  }
}

===== ./src/cli.rs =====

use clap::Parser;

#[derive(Parser, Debug)]
pub struct Args {
  #[arg(short = 'y', long = "year")]
  pub year: String,
  
  
  #[arg(short = 'd', long = "day")]
  pub day: String,
}

===== ./src/errors.rs =====

use std::fmt;
use std::error::Error;

#[derive(Debug)]
pub enum AocError {
  Unsupported,
  Io(std::io::Error),
  Invalid(String),
}

impl fmt::Display for AocError {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
	match self {
	  AocError::Unsupported => write!(f, "Día o año no soportado"),
	  AocError::Io(e) => write!(f, "IO error: {}", e),
	  AocError::Invalid(msg) => write!(f, "Input inválido: {}", msg),
	}
  }
}

impl Error for AocError {}

impl From<std::io::Error> for AocError {
  fn from(e: std::io::Error) -> Self { Self::Io(e) }
}


===== ./src/models.rs =====

pub struct DayResult {
  pub part1: String,
  pub part2: String,
}

impl DayResult {
  pub fn new(p1: impl Into<String>, p2: impl Into<String>) -> Self {
	Self { part1: p1.into(), part2: p2.into() }
  }
}

===== ./src/years.rs =====

pub mod y2024;

use crate::errors::AocError;

pub fn dispatch(year: u16, day: u8) -> Result<(), AocError> {
  match year {
	2024 => y2024::run_day(day),
	_ => Err(AocError::Unsupported),
  }
}

===== Cargo.toml (raíz) =====

[package]
name = "advent-of-code"
version = "0.1.0"
edition = "2024"

[dependencies]
clap = { version = "4.5.53", features = ["derive"] }
anyhow = "1.0.100"